package com.example.demo.shild_book.OOP.Polimorf;

import java.util.Arrays;
import java.util.List;

/**
 * https://javarush.ru/groups/posts/polimorfizm-v-java
 */
public class Main {
    public static void main(String[] args) {
//        exampleWithExtends();
        exampleWithInterface();
    }

    /**
     * Скорее всего, вас спросят, почему компилятор не будет «ругаться» на несоответствие типов,
     * объявленных слева и справа от знака присваивания, ведь в Java строгая типизация. Поясните, что тут работает
     * восходящее преобразование типов — ссылка на объект интерпретируется, как ссылка на базовый класс.
     * Причем компилятор, встретив в коде такую конструкцию, делает это автоматически и неявно.
     */
    public static void exampleWithExtends() {
        User user1 = new VipUser();
        User user2 = new User();

        List<User> userList = Arrays.asList(user2, user1);
        for (User user : userList) {
            user.printStatus();
        }

        System.out.println("___________");
    }

    /**
     * В Java по умолчанию используется позднее связывание
     * (на стадии выполнения программы, а не во время компиляции, как в случае с ранним связыванием).
     * Это значит, что при компиляции кода компилятор еще не знает, код из какого класса  он будет исполнять.
     * Это определится только при выполнении программы благодаря механизму
     * динамической диспетчеризации — проверки типа объекта во время выполнения программы и выбора нужной реализации метода для этого типа.
     *
     * Если вас спросят, как это реализовано, можете ответить, что при загрузке и инициализации объектов JVM строит таблицы в памяти,
     * и в них связывает переменные с их значениями, а объекты — с их методами. Причем если объект наследуется или имплементирует интерфейс,
     * в первую очередь проверяется наличие переопределенных методов в его классе. Если таковые есть,
     * они привязываются к этому типу, если нет – ищется метод, определенный в классе на ступень выше (в родителе) и так вплоть до корня при многоуровневой иерархии.
     */
    public static void exampleWithInterface() {
        User user = new User();
        Order order = new Order();
        Coupon coupon = new Coupon();

        List<StatisticInterface> statisticList = Arrays.asList(user, order, coupon);
        for (StatisticInterface stat : statisticList) {
            // Каким образом происходит выбор нужной реализации метода при выполнении программы?
            // Чтобы ответить на эти вопросы необходимо рассказать о позднем (динамическом) связывании.
            // Под связыванием понимают установление связи между вызовом метода и его конкретной реализацией, в классах.
            stat.saveStatistic();
            stat.exampleDefault();
            System.out.println("________");
        }
    }
}
